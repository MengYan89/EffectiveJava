# 第一条：用静态工厂方法替代构造器
类可以提供一个静态工厂方法(static factory method),它只是一个返回类的实例的静态方法。  
下面是一个来自Boolean(基本类型boolean的装箱类)的简单实例。
```java
public class Test {
    public static Boolean valueOf(boolean b) {
        return b ? Boolean.TRUE : Boolean.FALSE;
    }
}
```
注意，静态工厂方法与设计模式中的工厂方法(Factory Method)模式不同。并不对应于工厂方法。  
如果不通过公有的构造器， 或者说除了公有的构造器之外，类还可以给它的客户端提供静态工厂方法。
提供静态工厂方法而不是公有的构造器，这样做既有优势，也有劣势。
## 优势

### 与构造器相比，它们有名称
如果构造器的参数本身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用也更容易被阅读。  
例如，构造器BigInteger(int, int, Random)返回的BigInteger可能为素数，
如果用名为BigInteger.probablePrime的静态工厂方法来表示，显然更为清楚。(Java4版本中增加了这个方法。)  
BigInteger(int, int, Random)与BigInteger.probablePrime同是用于生成素数的方式

### 与构造器相比，不必在每次调用他们的时候都创建一个对象
这使得不可变类(详见[第17条]())可以使用预先建好的实例，获奖构建好的实例缓存起来，进行重复利用，从而避免创建
不必要的重复对象。Boolean.valueOf(boolean)方法说明了这项技术，它从来不创建对象。  
这种方法类类似于[享元(Flyweight)模式](#)。  
静态工厂方法能够为重复的调用返回相同的对象，这样有助于类总能够严格控制在某个时刻哪些实例应该存在。
这种类被称作实例受控制的类(instance-controlled)。编写实例受控的类有几个原因。  
实例受控使得类可以确保它是一个Singleton(单例 详见[第3条]())或者不可实例化的类(详见[第4条]())。  
它还使得不可变的值类(详见[第17条]())可以确保不会出现两个相等的实例，即当且仅当a==b时，one.equals(b)才为true。
枚举(enum)类型(详见[第34条]())保证了这一点。

### 与构造器相比，它们可以返回原返回类型的任何子类型的对象
这样我们在选择返回对象的类时就有了更大的灵活性。  
这项技术适用于基于接口的框架(interface-based framework)(详见[第20条]())，因为在这种框架中，接口为静态工厂方法
提供了自然返回类型。  
在Java8之前，接口不能有静态方法，因此按照惯例，接口Type的静态工厂方法被放在一个名为Types的不可实例化的伴生类(详见[第4条]())中。
例如，Java Collections Framework的集合接口有45个工具实现，分别提供了不可修改的集合、同步集合，等等。
几乎所有这些实现都通过静态工厂方法在一个不可实例化的类(Java.util.collections)中导出。所有返回对象的类都是非公有的。  

现在的Collections Framework API比导出45个独立公有类的那种实现方式要小得多，每种便利实现都对应一个类。这不仅仅是指API数量上的减少，
也是概念意义上的减少；为了使用这个API，用户必须掌握的概念在数量和难度上都减少了。程序员知道，被返回的对象是由相关的接口精确指定的，
所以他们不需要阅读有关的类文档。此外，使用这种静态工厂方法时，甚至要求客户端通过接口来引用被返回的对象，
而不是用过他的实现类来引用被返回的对象，这是一种良好的习惯(详见[第64条]())。  

从Java8版本开始，接口中不能包含静态方法的这一限制成为历史，因此一般没有任何理由给接口提供一个不可实例化的伴生类。
已经被放在这种类中的许多公有的静态成员，应该被放到接口中去。但是要注意，仍有必要将这些静态方法背后的大部分实现代码，
单独放进一个包级私有的类中。这是因为Java8中仍要求接口的所有静态成员必须都是公有的。在java9中允许接口有私有的静态方法，
但是静态域和静态成员类仍需要是公有的。  
### 所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值
只要是已声明的返回类型的子类型，都是允许的。返回对象的类也可能随着发行版本的不同而不同。  
EnumSet(详见[第36条]())没有公有的构造器，只有静态工厂方法。在OpenJDK实现中，他们返回两种子类之一的一个实例，
具体取决于底层枚举类的大小：如果它的元素有64个或者更少，就像大多数枚举类一样，静态工厂方法就会返回一个RegularEnumSet实例，
用单个long进行支持；如果枚举类型有65个或者更多元素，工厂就会返回JumboEnumSet实例，用一个long数组进行支持。  

这两个实现类的存在对于客户端来说是不可见的。如果RegularEnumSet不能再给小的枚举类提供性能优势，那么就可能从未来的发行版本中
将他删除，不会造成任何负面的影响。同样地，如果事实证明对性能有好处，也可能在未来的发行版本中添加第三甚至第四个
EnumSet实现。客户端永远不知道也不关心他们从工厂方法中得到的对象的类，他们只关心它是EnumSet的某个子类。  

### 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在
这种灵活的静态工厂方法构成了服务提供者框架（ Service Provider Framework）的基础，例如JDBC(Java 数据库连接）API。
服务提供者框架是指这样一个系统：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，
并把它们从多个实现中解稠出来。  

服务提供者框架中有三个重要的组件：服务接口（ Service Interface ），这是提供者实现的；
提供者注册API( Provider Registration API ），这是提供者用来注册实现的；
服务访问API(Service Access API)，这是客户端用来获取服务的实例。服务访问API是客户端用来指
定某种选择实现的条件。如果没有这样的规定，API就会返回默认实现的一个实例，或者允许客户端遍历所有可用的实现。
服务访问API 是“灵活的静态工厂”，它构成了服务提供者框架的基础。  

服务提供者框架的第四个组件服务提供者接口（Service Provider Interface）是可选的，它表示产生服务接口之实例的工厂对象。
如果没有服务提供者接口，实现就通过反射方式进行实例化（详见[第65条]()）。对于JDBC来说，Connection就是其服务接口的一部分，
DriverManager.registerDriver是提供者注册API，DriverManager.getConnection是服务访问API, Driver是服务提供者接口。  

服务提供者框架模式有着无数种变体。例如，服务访问API 可以返回比提供者需要的更丰富的服务接口。
这就是[桥接（Bridge）模式]()。依赖、注入框架（详见[第5条]()）可以被看作是一个强大的服务提供者。
从Java6版本开始，Java平台就提供了一个通用的服务提供者框架java.util.ServiceLoader，
因此你不需要（一般来说也不应该）再自己编写了（详见[第59条]()）。JDBC不用ServiceLoader，因为前者出现得比后者早。  

## 缺点

### 类如果不含有公有或者受保护的构造器，就不能被子类化
例如，想要将Collections Framework中的任何便利的实现类子类化，这是不可能的。但是这样也许会因祸得福，
因为他鼓励程序员使用复合(composition)，而不是继承(详见[第18条]()),这正是不可变类型所需要的(详见[第17条]()))。  

### 程序很难发现他们
在API文档中，它们没有像构造器那样在API文档中明确标识出来，因此对于提供了静态工厂方法而不是构造器的类来说，
要想查明如何实例化一个类是非常困难的。Javadoc工具总有一天会注意到静态工厂方法。同时，通过在类或者接口注释中关注静态工厂，
并遵守标准的命名习惯，也可以弥补这一劣势。  

下面时静态工厂方法的一些惯用名称。这里之类去了其中的一小部分：
```text
from---类型转换方法，它只有单个参数，返回该类型的一个对应的实例，例如：
    Date d = Date.from(instant);

of---聚合方法，带有多个参数，返回该类型的一个实例，把他们合并起来，例如：
    Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
    
valueOf---比from和of更繁琐的一种替代方法，例如：
    BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
    
instance或者getInstance---返回的实例时通过方法的参数来表述的，但是不能说与参数具有相同的值，例如:
    StackWalker luke = StackWalker.getInstance(options);
    
create或者newInstance---像instance或者getInstance一样，但是create或者newInstance能够确保每次调用都返回一个新的实例，例如:
    Object new Array = Array.newInstance(classObject, arrayLen);

getType---像getInstance一样，但是在工厂方法中存在不同的类的时候使用。Type代表工厂方法所返回的对象类型，例如：
    FileStore fs = Files.getFileStore(path);

newType---像newInstance一样，但是在工厂方法存在不同的类的时候使用。Type代表工厂方法所返回的对象类型，例如：
    BufferedReader br = Files.newBufferedReader(path);

type---getType和newType的简版,例如：
    List<Complaint> litany = Collections.list(legacyLitany);
```
简而言之，静态工厂方法和公有构造器都各有用处，我们需要理解他们各自的长处。静态工厂经常更加合适，
因此不要第一反应就是提供公有构造器，而需要优先考虑静态工厂。



